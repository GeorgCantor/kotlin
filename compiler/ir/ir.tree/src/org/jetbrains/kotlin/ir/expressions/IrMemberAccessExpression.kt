/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.expressions

import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI
import org.jetbrains.kotlin.ir.symbols.IrFunctionSymbol
import org.jetbrains.kotlin.ir.symbols.IrPropertySymbol
import org.jetbrains.kotlin.ir.symbols.IrSymbol
import org.jetbrains.kotlin.ir.types.IrType
import org.jetbrains.kotlin.ir.util.transformInPlace
import org.jetbrains.kotlin.ir.visitors.IrElementTransformer
import org.jetbrains.kotlin.ir.visitors.IrElementVisitor

// This class is not autogenerated to for the sake refactoring IR parameters - see KT-68003.
// However, it must be kept in sync with [org.jetbrains.kotlin.ir.generator.IrTree.memberAccessExpression].
abstract class IrMemberAccessExpression<S : IrSymbol> : IrDeclarationReference() {
    abstract override val symbol: S

    abstract var origin: IrStatementOrigin?


    val allArguments: ArrayList<IrExpression?> = ArrayList()

    var contextArgumentCount: Int = -1
        private set
    private var regularArgumentCount: Int = 0
    private var hasDispatchReceiver: Boolean = false
    private var hasExtensionReceiver: Boolean = false

    internal fun initializeTargetShape(
        contextParameterCount: Int,
        regularParameterCount: Int,
        isFromTargetUpdate: Boolean = false,
    ) {
        if (isFromTargetUpdate) {
            require(regularParameterCount + contextParameterCount == regularArgumentCount + contextArgumentCount)
            { "New symbol has different shape w.r.t value parameter count" }
        }

        contextArgumentCount = contextParameterCount
        regularArgumentCount = regularParameterCount

        val allParametersCount =
            (if (hasDispatchReceiver) 1 else 0) +
                    contextArgumentCount +
                    (if (hasExtensionReceiver) 1 else 0) +
                    regularArgumentCount

        allArguments.ensureCapacity(allParametersCount)
        repeat((allParametersCount - allArguments.size).coerceAtLeast(0)) {
            allArguments += null
        }
    }

    @OptIn(ObsoleteDescriptorBasedAPI::class)
    protected fun recordTargetShape() {
        val symbol = symbol
        when (symbol) {
            is IrFunctionSymbol -> {
                val target = symbol.owner
                initializeTargetShape(
                    target.contextReceiverParametersCount,
                    target.valueParameters.size - target.contextReceiverParametersCount,
                    isFromTargetUpdate = true,
                )
            }
            is IrPropertySymbol -> {
                initializeTargetShape(0, 0, isFromTargetUpdate = true)
            }
        }
    }

    val valueArgumentsCount: Int
        get() = regularArgumentCount + contextArgumentCount

    var dispatchReceiver: IrExpression?
        get() {
            return if (hasDispatchReceiver) {
                allArguments[0]
            } else {
                null
            }
        }
        set(value) {
            setReceiverArgument(0, value, hasDispatchReceiver)
            hasDispatchReceiver = value != null
        }

    var extensionReceiver: IrExpression?
        get() {
            return if (hasExtensionReceiver) {
                val index = getExtensionReceiverIndex()
                this.allArguments[index]
            } else {
                null
            }
        }
        set(value) {
            setReceiverArgument(getExtensionReceiverIndex(), value, hasExtensionReceiver)
            hasExtensionReceiver = value != null
        }

    private fun getExtensionReceiverIndex(): Int {
        return (if (hasDispatchReceiver) 1 else 0) + contextArgumentCount
    }

    private fun setReceiverArgument(index: Int, value: IrExpression?, alreadyHasThatReceiverParameter: Boolean) {
        if (alreadyHasThatReceiverParameter) {
            if (value != null) {
                allArguments[index] = value
            } else {
                allArguments.removeAt(index)
            }
        } else {
            if (value != null) {
                allArguments.add(index, value)
            } else {
                // nothing
            }
        }
    }

    fun getValueArgument(index: Int): IrExpression? {
        val actualIndex = getRealValueArgumentIndex(index)
        checkArgumentSlotAccess("value", actualIndex, this.allArguments.size)
        return this.allArguments[actualIndex]
    }

    fun putValueArgument(index: Int, valueArgument: IrExpression?) {
        val actualIndex = getRealValueArgumentIndex(index)
        checkArgumentSlotAccess("value", actualIndex, this.allArguments.size)
        this.allArguments[actualIndex] = valueArgument
    }

    private fun getRealValueArgumentIndex(index: Int): Int =
        (if (hasDispatchReceiver) 1 else 0) +
                (if (hasExtensionReceiver && index >= contextArgumentCount) 1 else 0) +
                index


    protected abstract val typeArguments: Array<IrType?>

    val typeArgumentsCount: Int
        get() = typeArguments.size

    fun getTypeArgument(index: Int): IrType? {
        checkArgumentSlotAccess("type", index, typeArguments.size)
        return typeArguments[index]
    }

    fun putTypeArgument(index: Int, type: IrType?) {
        checkArgumentSlotAccess("type", index, typeArguments.size)
        typeArguments[index] = type
    }


    override fun <D> acceptChildren(visitor: IrElementVisitor<Unit, D>, data: D) {
        allArguments.forEach { it?.accept(visitor, data) }
    }

    override fun <D> transformChildren(transformer: IrElementTransformer<D>, data: D) {
        allArguments.transformInPlace(transformer, data)
    }
}