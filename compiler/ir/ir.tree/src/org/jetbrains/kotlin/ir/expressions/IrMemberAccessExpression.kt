/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.expressions

import org.jetbrains.kotlin.builtins.StandardNames.FqNames.target
import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI
import org.jetbrains.kotlin.ir.declarations.IrDeclarationOrigin
import org.jetbrains.kotlin.ir.declarations.IrFunction
import org.jetbrains.kotlin.ir.declarations.IrProperty
import org.jetbrains.kotlin.ir.declarations.IrSymbolOwner
import org.jetbrains.kotlin.ir.symbols.IrBindableSymbol
import org.jetbrains.kotlin.ir.symbols.IrSymbol
import org.jetbrains.kotlin.ir.symbols.impl.IrFakeOverrideSymbolBase
import org.jetbrains.kotlin.ir.types.IrType
import org.jetbrains.kotlin.ir.util.resolveFakeOverrideMaybeAbstractOrFail
import org.jetbrains.kotlin.ir.util.transformInPlace
import org.jetbrains.kotlin.ir.visitors.IrElementTransformer
import org.jetbrains.kotlin.ir.visitors.IrElementVisitor

// This class is not autogenerated to for the sake refactoring IR parameters - see KT-68003.
// However, it must be kept in sync with [org.jetbrains.kotlin.ir.generator.IrTree.memberAccessExpression].
abstract class IrMemberAccessExpression<S : IrSymbol> : IrDeclarationReference() {
    abstract override val symbol: S

    abstract var origin: IrStatementOrigin?


    val allArguments: ArrayList<IrExpression?> = ArrayList()

    var targetContextParameterCount: Int = -1
        private set
    var targetHasDispatchReceiver: Boolean = false
        private set
    var targetHasExtensionReceiver: Boolean = false
        private set
    private var targetRegularParameterCount: Int = 0

    internal fun initializeTargetShapeExplicitly(
        hasDispatchReceiver: Boolean,
        hasExtensionReceiver: Boolean,
        contextParameterCount: Int,
        regularParameterCount: Int,
        isFromTargetUpdate: Boolean = false,
    ) {
        if (isFromTargetUpdate) {
            require(hasDispatchReceiver == targetHasDispatchReceiver) { "New symbol has different shape w.r.t dispatch receiver" }
            require(hasExtensionReceiver == targetHasExtensionReceiver) { "New symbol has different shape w.r.t extension receiver" }
            require(regularParameterCount + contextParameterCount == targetRegularParameterCount + targetContextParameterCount)
            { "New symbol has different shape w.r.t value parameter count" }
        }

        targetHasDispatchReceiver = hasDispatchReceiver
        targetHasExtensionReceiver = hasExtensionReceiver
        targetContextParameterCount = contextParameterCount
        targetRegularParameterCount = regularParameterCount

        val allParametersCount =
            (if (targetHasDispatchReceiver) 1 else 0) +
                    targetContextParameterCount +
                    (if (targetHasExtensionReceiver) 1 else 0) +
                    targetRegularParameterCount

        allArguments.ensureCapacity(allParametersCount)
        repeat((allParametersCount - allArguments.size).coerceAtLeast(0)) {
            allArguments += null
        }
    }

    @OptIn(ObsoleteDescriptorBasedAPI::class)
    internal fun initializeTargetShapeFromSymbol(isFromTargetUpdate: Boolean = false) {
        @Suppress("UNCHECKED_CAST")
        val target = (symbol as IrBindableSymbol<*, IrSymbolOwner>).getRealOwner()
        when (target) {
            is IrFunction -> {
                initializeTargetShapeExplicitly(
                    target.dispatchReceiverParameter != null,
                    target.extensionReceiverParameter != null,
                    target.contextReceiverParametersCount,
                    target.valueParameters.size - target.contextReceiverParametersCount,
                    isFromTargetUpdate = isFromTargetUpdate,
                )
            }
            is IrProperty -> {
                val hasDispatchReceiver: Boolean
                val hasExtensionReceiver: Boolean

                val accessor = when (this) {
                    is IrPropertyReference -> (getter ?: setter)?.getRealOwner()
                    is IrLocalDelegatedPropertyReference -> getter.owner
                    else -> error("Unexpected reference to a property from $this")
                }
                if (accessor != null) {
                    hasDispatchReceiver = accessor.dispatchReceiverParameter != null
                    hasExtensionReceiver = accessor.extensionReceiverParameter != null
                } else {
                    val realProperty = target.resolveFakeOverrideMaybeAbstractOrFail()
                    if (realProperty.origin == IrDeclarationOrigin.IR_EXTERNAL_JAVA_DECLARATION_STUB
                        || realProperty.origin == IrDeclarationOrigin.SYNTHETIC_JAVA_PROPERTY_DELEGATE
                    ) {
                        hasDispatchReceiver = !realProperty.backingField!!.isStatic
                        hasExtensionReceiver = false
                    } else {
                        error("Cannot infer the shape of property $symbol, please specify it explicitly")
                    }
                }

                initializeTargetShapeExplicitly(
                    hasDispatchReceiver,
                    hasExtensionReceiver,
                    0,
                    0,
                    isFromTargetUpdate = isFromTargetUpdate,
                )
            }
        }
    }

    protected fun updateTargetSymbol() {
        initializeTargetShapeFromSymbol(isFromTargetUpdate = true)
    }

    private fun <S : IrBindableSymbol<*, D>, D : IrSymbolOwner> S.getRealOwner(): D {
        var symbol = this
        if (this is IrFakeOverrideSymbolBase<*, *, *>) {
            @Suppress("UNCHECKED_CAST")
            symbol = originalSymbol as S
        }
        return symbol.owner
    }

    val valueArgumentsCount: Int
        get() = targetRegularParameterCount + targetContextParameterCount

    var dispatchReceiver: IrExpression?
        get() {
            return if (targetHasDispatchReceiver) {
                allArguments[0]
            } else {
                null
            }
        }
        set(value) {
            targetHasDispatchReceiver = setReceiverArgument(0, value, targetHasDispatchReceiver)
        }

    var extensionReceiver: IrExpression?
        get() {
            return if (targetHasExtensionReceiver) {
                val index = getExtensionReceiverIndex()
                allArguments[index]
            } else {
                null
            }
        }
        set(value) {
            targetHasExtensionReceiver = setReceiverArgument(getExtensionReceiverIndex(), value, targetHasExtensionReceiver)
        }

    private fun getExtensionReceiverIndex(): Int {
        return (if (targetHasDispatchReceiver) 1 else 0) + targetContextParameterCount
    }

    private fun setReceiverArgument(index: Int, value: IrExpression?, targetHasThatReceiverParameter: Boolean): Boolean {
        if (targetHasThatReceiverParameter) {
            if (value != null) {
                allArguments[index] = value
                return true
            } else {
                if (allArguments[index] != null) {
                    allArguments.removeAt(index)
                    return false
                } else {
                    return true
                }
            }
        } else {
            if (value != null) {
                allArguments.add(index, value)
                return true
            } else {
                return false
            }
        }
    }

    fun getValueArgument(index: Int): IrExpression? {
        val actualIndex = getRealValueArgumentIndex(index)
        checkArgumentSlotAccess("value", actualIndex, this.allArguments.size)
        return this.allArguments[actualIndex]
    }

    fun putValueArgument(index: Int, valueArgument: IrExpression?) {
        val actualIndex = getRealValueArgumentIndex(index)
        checkArgumentSlotAccess("value", actualIndex, this.allArguments.size)
        this.allArguments[actualIndex] = valueArgument
    }

    private fun getRealValueArgumentIndex(index: Int): Int =
        (if (targetHasDispatchReceiver) 1 else 0) +
                (if (targetHasExtensionReceiver && index >= targetContextParameterCount) 1 else 0) +
                index


    protected abstract val typeArguments: Array<IrType?>

    val typeArgumentsCount: Int
        get() = typeArguments.size

    fun getTypeArgument(index: Int): IrType? {
        checkArgumentSlotAccess("type", index, typeArguments.size)
        return typeArguments[index]
    }

    fun putTypeArgument(index: Int, type: IrType?) {
        checkArgumentSlotAccess("type", index, typeArguments.size)
        typeArguments[index] = type
    }


    override fun <D> acceptChildren(visitor: IrElementVisitor<Unit, D>, data: D) {
        allArguments.forEach { it?.accept(visitor, data) }
    }

    override fun <D> transformChildren(transformer: IrElementTransformer<D>, data: D) {
        allArguments.transformInPlace(transformer, data)
    }
}